## 1.GBDT(Gradient Boosting Decison Tree)梯度提升树
GBDT与提升树有非常密切的关系。为方便阅读本文，可以先参考[提升树](https://blog.csdn.net/bitcarmanlee/article/details/106835782)一文。

在提升树一文中，我们提到每一轮迭代，都是去拟合上一轮的"残差"，如果用一个简单的公式表示就是$y_i - f_{m-1}(x)$

GBDT与上面普通提升树的不同在于，其拟合的不是残差，而是梯度下降的方向。也就是将残差的计算替换为损失函数梯度的计算：
$$r_{mi} = -\left[ \frac{\partial L(y_i,f(x_i))}{\partial f(x_i)} \right ]_{f(x)=f_{m-1}(x)}$$  

如果损失函数为MSE, 损失函数为$L(y_i,f(x_i)) = \frac{1}{2}(y_i - f(x_i))^2$，此时模型的负梯度方向即为残差方向$r_{mi} = y_i - f(x_i)$。

如果将GBDT名字拆开比较好理解，包含了三个关键的部分
1.G(Gradient) 梯度(残差)
2.B(Boosting) 提升方法，即为加法模型与前向分布算法
3.DT(Decision Tree) CART回归树，弱学习器。

所以将GBDT算法的流程做个总结如下:  
一、初始化  
$$f_0(x) = argmin_c \sum_{i=1}^N L(y_i, c)$$  
使损失函数最小，其只是一个根节点的树。  
二、对m=1, 2, …M  
2.1 计算梯度(残差)   
$$\large{r_{mi}} = -{\left[\frac{\partial L(y_i,f(x_i))}{\partial f(x_i)} \right]}_{f(x)=f_{m-1}(x)}$$
即将损失函数的负梯度在当前模型的值，将它作为残差的估计(如果是MSE，就是通常意义所说的残差。如果是其他损失函数，则为残差的近似)  
2.2 得到一个新的回归树$T(x;\theta_m)$  
2.3 更新$f_m(x) = f_{m-1}(x) + T(x; \theta_m)$      
三、得到最终的模型   
$$f_M(x) = \sum_{m=1}^M T(x; \theta_m)$$

## 2.GBDT与提升树的关系
提升树每一次所谓的提升过程，都是通过上次的预测结果与真实值的差值作为新的训练数据进行训练。因为CART树默认的损失函数为MSE，所以直接使用残差进行计算。
而GBDT针对的是更为一般的损失函数，所以用负梯度近似代替残差，将上次预测结果代入梯度中来获取本轮的训练数据。
本质上是在生成新的训练数据的时候采用了不同的方式。

## 3.GBDT与传统Boosting方法的区别
GBDT每次的计算是为了减小上一次的残差(residual)。而为了消除残差，可以在残差减少的梯度(Gradient)方向上建立一个新的模型。因此在Gradient Boosting中，每个新的模型的建立是为了使得之前模型的残差往梯度方向减少。而传统Boosting的方法是对正确，错误样本进行不同程度加权有比较大的区别。

## 4.GBDT为什么精度比较高
西瓜书(周志华老师出品的机器学习)中对此有解释：Boosting主要关注降低偏差，因此Boosting能基于泛化性能相当弱的学习器构建出很强的集成；Bagging主要关注降低方差，因此它在不剪枝的决策树、神经网络等学习器上效用更为明显。

## 5.GBDT优缺点
优点
1.可以灵活处理各种类型数据，包括连续值与离散值。
2.非线性能力比较强，表达能力强，不需要做复杂的特征工程和特征变换。
3.在相对较少调参的情况下，可以达到比较高的精度。
4.可解释性强，可以自动做特征重要性排序。因此在深度学习火热以前，常作为`发现特征组合‘的有效思路。
5.使用一些健壮的损失函数，对异常值的鲁棒性较高。比如Huber loss。

缺点
1.boost训练是串行过程，不好并行化。
2.计算复杂度高，不太适合高维稀疏特征，如果feature个数太多，每一棵回归树都要耗费大量时间
